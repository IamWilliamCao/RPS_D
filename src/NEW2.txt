
if (inBattle) {
    return (
      <div className="battle-screen fade-in">

        {/* ENEMY HEADER */}
        <div className="enemy-header multiple-enemies">
          {enemies.map((enemy, index) => (
            <div
                key={index}
                className={`enemy-display ${!enemy.alive ? 'fade-out' : ''}`}
                style={{ display: hiddenEnemies.includes(index) ? 'none' : 'block' }}
              >
              <img
                src={`${process.env.PUBLIC_URL}/Sprites/Enemies/${enemy.image}`}
                alt={enemy.name}
                className={`enemy-image ${flip ? 'enemyFlip' : ''}`} 
                ref={(el) => (enemyImageRefs.current[index] = el)}
                onMouseEnter={() => setHoveredEnemyIndex(index)}
                onMouseLeave={() => setHoveredEnemyIndex(null)}
                style={{ cursor: 'pointer' }}
              />

              <h2 className="enemy-name">{enemy.name}</h2>

              {hoveredEnemyIndex === index && (
                <div className="enemy-tooltip">
                  <strong>{enemy.name}</strong>
                  {enemy.weakness?.length > 0 && (
                    <div>
                      <strong>Weakness:</strong>
                      {enemy.weakness.map((w, idx) => (
                        <div key={idx}>{w.name} - {w.debuff}x</div>
                      ))}
                    </div>
                  )}
                  {enemy.strength?.length > 0 && (
                    <div>
                      <br></br>
                      <strong>Resistance:</strong>
                      {enemy.strength.map((w, idx) => (
                        <div key={idx}>{w.name} - {w.buff}x</div>
                      ))}
                    </div>
                  )}
                </div>
              )}

              <p>HP: {displayEnemyHPs[index]}</p>
            </div>
          ))}
        </div>

        {/* ENEMY PLAYED CARDS */}
        <div className="battle-info">
          <h3 className="fontsize">Enemy Play Order:</h3>
          <div className="card-row horizontal">
            {(() => {
              const enemyDisplay = [...enemyPlayed];
              while (enemyDisplay.length < playerPlayed.length) {
                enemyDisplay.push(null);
              }
              return enemyDisplay.map((cardObj, i) => {
                const card = cardObj?.type;
                const enemyIndex = cardObj?.enemyIndex;
                const enemy = enemies[enemyIndex];
                const isDead = enemy && !enemy.alive;

                let className = "card shaped";
                if (phase === 'shoot' && shootIndex === i) className += " highlight";
                if (enemyHighlights[i] === 'win') className += " green";
                else if (enemyHighlights[i] === 'lose') className += " red";
                if (!card || isDead) className += " blank";
                if (
                  hoveredEnemyIndex != null &&
                  enemyIndex === hoveredEnemyIndex &&
                  phase === 'highlight'
                ) {
                  className += " hover-highlight";
                }

                const move = enemy?.moves.find(m => m.type === card);

                return (
                  <div
                    key={i}
                    className={className}
                    ref={(el) => (enemyCardRefs.current[i] = el)}
                    onMouseEnter={() => setHoveredCardIndex(i)}
                    onMouseLeave={() => setHoveredCardIndex(null)}
                    style={{ position: 'relative' }}
                  >
                    {!card || isDead ? (
                      '—'
                    ) : (
                      <>
                        {move?.name || card}
                        <div className="tooltip">
                        <strong>{move?.name}</strong>: {move?.description}
                        <br />
                        {Array.isArray(move?.type) && move.type.includes("Heal") ? "Heal" : "Damage"}: {
                        move?.name === 'Vengebite' && (phase === 'highlight' || phase === 'shoot')
                          ? 10 + 5 * enemyPlayed.filter(
                              (p, idx) =>
                                p?.enemyIndex !== enemyIndex &&
                                p?.type &&
                                p.type !== 'Hide'
                            ).length
                          : move?.damage
                      }
                      </div>
                      </>
                    )}
                  </div>
                );
              });
            })()}
          </div>

          <div className="turn-indicator">
            <h3 style={{ textAlign: 'center' }}>
              Turn {battleTurn}
            </h3>
          </div>

          {/* Player Played Cards */}
          <div className="card-row horizontal">
            {(() => {
              const playerDisplay = [...playerPlayed];
              while (playerDisplay.length < enemyPlayed.length) {
                playerDisplay.push(null);
              }

              return playerDisplay.map((card, i) => {
                let className = "card shaped selected";
                if (selectedSwapIndexes.includes(i)) className += " selected-swap";
                if (phase === 'shoot' && shootIndex === i) className += " highlight";
                if (playerHighlights[i] === 'win') className += " green";
                else if (playerHighlights[i] === 'lose') className += " red";
                if (!card) className += " blank";

                const data = cardData[card];

                return (
                  <div
                  key={i}
                  className={className}
                  onClick={() => {
                    if (phase === 'highlight') {
                    const hasSwitchroo = playerHand.includes('Scroll of Switchroo') && !playerPlayed.includes('Scroll of Switchroo');
                      if (hasSwitchroo && !switchrooUsed) {
                        if (selectedSwapIndexes.includes(i)) {
                          setSelectedSwapIndexes(selectedSwapIndexes.filter(idx => idx !== i));
                        } else if (selectedSwapIndexes.length < 2) {
                          setSelectedSwapIndexes([...selectedSwapIndexes, i]);
                        }

                        if (selectedSwapIndexes.length === 1) {
                        const [a] = selectedSwapIndexes;
                        const b = i;

                        if (a !== b) {
                        setPreSwitchPlayerPlayed([...playerPlayed]);

                        const newOrder = [...playerPlayed];
                        [newOrder[a], newOrder[b]] = [newOrder[b], newOrder[a]];
                        setPlayerPlayed(newOrder);
                        setSwitchrooUsed(true);
                        setSelectedSwapIndexes([]);
                        }
                        }

                      }

                    } else if (phase === 'player' && card) {
                      setPlayerPlayed(prev => prev.filter((_, idx) => idx !== i));

                    } else if (phase === 'player' && card === null) {
                      // Remove the clicked null
                      setPlayerPlayed(prev => {
                        const updated = [...prev];
                        updated.splice(i, 1); // remove the clicked null
                        return updated;
                      });

                      // Reduce use count and shift nullIndexes accordingly
                      setPlaceholderUsesThisTurn(prev => Math.max(prev - 1, 0));
                      setPlaceholderNullIndexes(prev => prev.filter(idx => idx !== i).map(idx => (idx > i ? idx - 1 : idx)));
                    }
                  }}
                  style={{
                    cursor: phase === 'player' && card ? 'pointer' : 'default',
                    position: 'relative'
                  }}
                >
                  {data?.name || card || '—'}
                  {card && data && (
                    <div className="tooltip">
                    <strong>{data.displayName || data.name}</strong>
                    {(Array.isArray(data.description) ? data.description : [data.description])
                      .map((line, i) => (
                        <React.Fragment key={i}>
                          <br />
                          {line}
                        </React.Fragment>
                      ))
                    }
                    <br />
                    Damage: {data.damage}
                  </div>
                  )}
                </div>
                );
              });
            })()}
          </div>
        </div>

        <h3 className="fontsize">HP: {displayPlayerHP}</h3>

        {/* PLAYER HAND */}
        <div className="player-hand-section">
          <h3 className="fontsize">Your Moves</h3>
          <div className="card-row horizontal">
            {playerHand
              .filter(card => !bannedCardsThisBattle.includes(card))
              .map((card, i) => {
              const data = cardData[card];
              const isPlaceholder = card === "Placeholder";
              const placeholderUsedUp = isPlaceholder && placeholderUsesThisTurn >= 3;
              const isUsed = playerPlayed.includes(card);

              return (
                <div
                  key={i}
                  className={`card shaped ${isUsed ? 'used' : ''} ${
                    card === 'Scroll of Switchroo' && phase === 'highlight' && !switchrooUsed ? 'switchroo-glow' : ''
                  }`}
                  onClick={() => {
                    if (phase === 'player') {
                      if (isPlaceholder && !placeholderUsedUp) playCard(card);
                      else if (!isPlaceholder && !isUsed) playCard(card);
                    }
                  }}
                  style={{
                    cursor:
                      phase !== 'player' ||
                      (isPlaceholder && placeholderUsedUp) ||
                      (!isPlaceholder && isUsed)
                        ? 'not-allowed'
                        : 'pointer',
                    opacity:
                      isPlaceholder && placeholderUsedUp
                        ? 0.4
                        : isUsed
                        ? 0.4
                        : 1,
                  }}
                >
                  {data.displayName || data.name}
                  <div className="tooltip">
                    <strong>{data.displayName || data.name}</strong>
                    {(Array.isArray(data.description) ? data.description : [data.description]).map((line, i) => (
                      <React.Fragment key={i}>
                        <br />
                        {line}
                      </React.Fragment>
                    ))}
                    <br />
                    Damage: {data.damage}
                  </div>
                </div>
              );
            })}
          </div>
        </div>


        {/* CONTINUE BUTTON */}
        {phase === 'highlight' && (
          <div style={{ textAlign: 'center', marginTop: '1rem' }}>
            {switchrooUsed && !playerPlayed.includes('Scroll of Switchroo') && (
              <button
                onClick={() => {
                  if (preSwitchPlayerPlayed) {
                    setPlayerPlayed(preSwitchPlayerPlayed);
                    setSelectedSwapIndexes([]);
                    setSwitchrooUsed(false); // allows glow again
                    setPreSwitchPlayerPlayed(null); // reset so it can retrigger on next Scroll of Switchroo play
                    setShowSwitchrooMessage(false); 
                  }
                }}
                style={{
                  backgroundColor: '#eee',
                  color: '#333',
                  padding: '0.4rem 0.8rem',
                  border: '1px solid #aaa',
                  borderRadius: '4px',
                  marginBottom: '1rem',
                  cursor: 'pointer',
                }}
              >
                ⟲ Revert Swap
              </button>
            )}

            <button
              className="continue-button"
              onClick={() => {
                if (playerPlayed.includes('Scroll of Switchroo')) setSwitchrooUsed(true);

                setPhase('shoot');
              }}
            >
              Continue →
            </button>
          </div>
        )}

        {/* END TURN BUTTON */}
        <div className="bottom-bar">
          <button onClick={endPlayerTurn} disabled={phase !== 'player'}>
            End Turn
          </button>
        </div>

{/* SVG LINE FROM CARD TO ENEMY */}
        <svg className="battle-line-layer">
          {hoveredCardIndex != null && (() => {
            const cardObj = enemyPlayed[hoveredCardIndex];
            const cardEl = enemyCardRefs.current[hoveredCardIndex];
            const enemyEl = enemyImageRefs.current[cardObj?.enemyIndex];
            const card = cardObj?.type;

            const enemy = enemies[cardObj?.enemyIndex];
            if (!cardEl || !enemyEl || !enemy || !enemy.alive) return null;


            const cardRect = cardEl.getBoundingClientRect();
            const enemyRect = enemyEl.getBoundingClientRect();

            const x1 = cardRect.left + cardRect.width / 2;
            const y1 = cardRect.top + cardRect.height / 2;
            const x2 = enemyRect.left + enemyRect.width / 2;
            const y2 = enemyRect.top + enemyRect.height / 2;

            return (
              <line
              x1={x1}
              y1={y1}
              x2={x2}
              y2={y2}
              stroke="gold"
              strokeWidth="2"
              strokeDasharray="4 4"
              className="animated-line"
            />
            );
          })()}
        </svg>

        {victory && <div className="victory-overlay">Victory!</div>}
      </div>
    );
}
